#pragma once
#include <cmath>
#include <QScrollBar>
#include <QShortcut>
#include "board_items.h"

namespace ard 
{
	template<class BB>
	class board_page : public topic_tab_page
	{
	public:
		board_page();
		~board_page() {};

		topic_ptr				topic()override { return m_bb; }
		BB*						board()			{ return m_bb; }
		ArdGraphicsView*		view()			{ return m_view; }
		ArdGraphicsScene*		scene()			{return m_scene;}
		ArdGraphicsView*		header_view()	{ return m_header_view; }

		virtual void			rebuildBoard() = 0;
		virtual void			resetBand(const std::unordered_set<int>& bands2reset);
		virtual void            removeSelected(bool silently) = 0;
		
		/// first selected in board, not in scene, we don't use scene selection-functions
		board_g_topic<BB>*		firstSelected();
		/// list of selected gitems, we maintain list in board and don't rely upon scene selected list
		GBLIST<BB>				selectedGBItems();
		/// list of topics of selected gitems
		TOPICS_LIST				selectedRefTopics();
		/// topic of the first selected gitem
		ard::topic*				firstSelectedRefTopic();
		/// list of gitems generated by topic
		GBLIST<BB>&				findGBItems(ard::topic* refTopic);
		/// resize to context all related gitems
		void					resizeGBItems(ard::topic* refTopic);
		/// collect all gitems related to topic, remove them from scene, return bands affected
		std::unordered_set<int>	removeTopicGBItems(const TOPICS_LIST& refTopics);
		/// remove gitems in one band - we collect all topics in the band and remove gitems
		/// we don't remove topic items that might be in other bands
		/// we also update mselect list
		virtual int				removeBandGBItems(int bindex);
		void					applySelectionCommand(topic_function cmd);
		void					clearSelectedGBItems();
		void					clearSelectedMarks();
		void					updateSelectedMarks();
		bool					hasMSelection()const;
		void					selectAsCurrent(board_g_topic<BB>*);
		std::unordered_set<int>	gitems2bands(const GBLIST<BB>& lst);

		virtual void			updateCurrentRelated(board_g_topic<BB>*);
		virtual void			clearCurrentRelated();

		board_g_topic<BB>*		ensureVisible(ard::topic* refTopic, bool animate = true);
		void					ensureVisible(board_g_topic<BB>* g, bool animate = true);

		TextFilter*         text_filter();
		virtual void		onBandDragEnter(board_band<BB>*, QGraphicsSceneDragDropEvent *) {};
		virtual void		onBandDragMove(board_band<BB>*, QGraphicsSceneDragDropEvent *) {};
		virtual void		onBandDragDrop(board_band<BB>*, QGraphicsSceneDragDropEvent *) {};
		virtual void		processMoved(board_g_topic<BB>*) {};

		virtual bool        isInLinkMode()const { return false; }
		bool				isInEditMode()const { return (m_curr_editor != nullptr); }
		virtual bool        isInCreateFromTemplateMode()const { return false; };
		virtual bool        isInInsertMode()const { return false; };
		virtual bool        isInCustomEditMode()const { return false; };
		virtual bool        isInLocateMode()const { return false; };

		void				registerBoardTopic(board_g_topic<BB>*, board_band_info* band);
		virtual void        createBoardTopic(const QPointF&) {};
		bool				completeMSelect();
		int					resizeMSelect(QPointF);
		virtual void        suggestCreateFromTemplateAtPos(const QPointF&) {}
		void				initMSelect(QPointF ptScene);
		void                updateMSelected();
		bool                isMSelected(board_g_topic<BB>*it)const;
		void                addMSelected(std::unordered_set<ard::board_g_topic<BB>*>& sel_lst);
		void                selectAllGBItems();
		void				pushSelected();
		void				popSelected();
		void				selectTopics(TOPICS_LIST& lst);
		void				selectGItem(board_g_topic<BB>*);
		void				selectNext(Next2Item);

		std::pair<ard::board_band<BB>*, ard::board_band_header<BB>*>
								register_band(ard::board_band_info* band);
		ard::board_band<BB>*	bandAt(int band_index);
		int						bandIndexAtPos(int xpos);
		void					initBandSplitter(int init_splitter_x);
		void					resizeBandSplitter(int splitter_x);
		void					applyBandSplitter(int band_index, int splitter_x);
		void					applyBandSplitterSetDefaultSize(int band_index);
		void					rebuildBands();

		void					setCurrentBand(int band_idx);
		int						currentBand()const;
		void					attachTopic(BB*);
		void					saveModified()override;
		void					detachCardOwner()override;
		void					updateHeader();

		void					enterEditMode(ard::board_editor<BB>* );
		void					exitEditMode();
		void					editComment(board_g_topic<BB>*);
		void					detachEditor();

		virtual void			enterLocateMode() {};
		virtual void			exitLocateMode() {};
		virtual void			enterInsertMode() {};
		virtual void			exitInsertMode() {};
		virtual void			enterRemoveMode() {};
		virtual void			exitRemoveMode() {};
		virtual void			enterLinkMode() {};
		virtual void			exitLinkMode() {};
		virtual void			exitCustomEditMode() {};

		void					showProperties();
		void					locateInSelector();
		virtual void			showLinkProperties() {};
		virtual void			insertFromTemplate(const QPoint&) {};
		virtual void			selectShape(ard::BoardItemShape, const QPoint&) {};
		virtual void			applyTextFilter() {}
		virtual void			copyToClipboard();
		virtual void			pasteFromClipboard() {}
		virtual void			markAsRead(bool) {}
		virtual std::pair<bool, QString>renameCurrent() { return std::pair<bool, QString>{false, "Operation disabled"}; };
		std::pair<bool, QString>renameGItem(board_g_topic<BB>*);
		bool					isRegularSlideLocked()const override{ return false; }

		virtual void			onBandControl(board_band_header<BB>*) {};
		virtual void			onMovedInBands(const std::unordered_set<int>&) {};
	protected:
		///index in vector
		int					indexOfGItem(const board_g_topic<BB>* g, const GBLIST<BB>& lst)const;
		///geometrically closest
		int					closestToGItem(const board_g_topic<BB>* g, const GBLIST<BB>& lst)const;
		virtual ard::board_band_header<BB>* produceBandHeader(ard::board_band_info* band);
		void				constructBoard(BB* b, std::vector<EBoardCmd> commands, std::vector<EBoardCmd> rcommands);
		void                repositionInBand(board_band_info*, board_g_topic<BB>*, int xpos, int ypos);
		virtual void        clearBoard();
		void                alignBandHeights();
		void				makeThumbnail();
		virtual void        repositionActionButtons(board_g_topic<BB>* ) {};
		virtual void        setupActionButtonInCaseCustomEditMode() {};
		virtual void		updateToolbar();
		void				prepareMSelected();

		BB*								m_bb{ nullptr };
		ArdGraphicsScene*				m_scene{ nullptr };
		ArdGraphicsView*				m_view{ nullptr };
		ard::board_page_toolbar<BB>*    m_toolbar{ nullptr };
		ArdGraphicsScene*				m_header_scene{ nullptr };
		ArdGraphicsView*				m_header_view{ nullptr };
		BAND2G<BB>						m_band2g;
		BH2G<BB>						m_bh2g;
		T2L<BB>							m_ref2glst;
		B2L<BB>							m_band2glst;		
		std::unique_ptr<TextFilter>		m_text_filter;
		ard::board_band_splitter*		m_band_splitter{ nullptr };
		int								m_band_splitter_init_x{ 0 },
										m_max_xright{ 0 }, m_max_ybottom{ 0 };
		int								m_outline_index{ 0 };
		QPointF							m_ptMselectorStart;		
		MS_LIST<BB>						m_selected_marks;
		B2TLIST							m_stored_selected;
		ard::board_selector_rect*		m_mselector{ nullptr };
		ard::board_editor<BB>*			m_curr_editor{ nullptr };
		ard::search_edit*				m_filter_edit{ nullptr };
		QTimer							m_animation_timer;
		bool							m_center_items_in_band{true};
	};
};

///  board_page /////
template<class BB>
ard::board_page<BB>::board_page() :topic_tab_page(QIcon(":ard/images/unix/board"))
{
	m_scene = new ArdGraphicsScene;
	m_header_scene = new ArdGraphicsScene;
	m_text_filter.reset(new TextFilter);

	auto sh = new QShortcut(QKeySequence("Ctrl+c"), this);
	connect(sh, &QShortcut::activated, [&]()
	{
		copyToClipboard();
	});
	sh = new QShortcut(QKeySequence("Ctrl+v"), this);
	connect(sh, &QShortcut::activated, [&]()
	{
		pasteFromClipboard();
	});
};

template<class BB>
void ard::board_page<BB>::constructBoard(BB* b, std::vector<EBoardCmd> commands, std::vector<EBoardCmd> rcommands)
{
	m_view->setScene(m_scene);
	m_view->setFrameShape(QFrame::NoFrame);
	m_toolbar = new ard::board_page_toolbar<BB>(this, commands, rcommands);
	m_filter_edit = new ard::search_edit;
	m_filter_edit->setMaximumWidth(100);
	connect(m_filter_edit, &ard::search_edit::applyCommand, [&]() {applyTextFilter(); });
	connect(m_filter_edit, &ard::search_edit::escapeCommand, [&]() {m_filter_edit->setText(""); });

	m_header_view = new ArdGraphicsView;
	m_header_view->setScene(m_header_scene);
	m_header_view->setFrameShape(QFrame::NoFrame);
	m_header_view->setNoScrollBars();
	m_header_view->setMaximumHeight(gui::lineHeight());

	connect(m_view->horizontalScrollBar(), &QScrollBar::valueChanged, [&](int v)
	{
		m_header_view->horizontalScrollBar()->setValue(v);
	});

	auto hl = new QHBoxLayout();
	utils::setupBoxLayout(hl);
	hl->addWidget(m_header_view);
	int w = qApp->style()->pixelMetric(QStyle::PM_ScrollBarExtent);
	auto hspacer = new QWidget;
	hspacer->setMaximumSize(w,w);
	hspacer->setMinimumSize(w, w);
	hl->addWidget(hspacer);
		
	QHBoxLayout* ht = new QHBoxLayout;
	ht->addWidget(m_toolbar);
	ht->addWidget(m_filter_edit);
	m_page_context_box->addLayout(ht);
	m_page_context_box->addLayout(hl);
	m_page_context_box->addWidget(m_view);
	attachTopic(b);
};

template<class BB>
void ard::board_page<BB>::resetBand(const std::unordered_set<int>& blst)
{
	for (auto& i : blst)
	{
		assert_return_void(i < static_cast<int>(m_band2glst.size()), QString("invalid band index [%1] [%2]").arg(i).arg(m_band2glst.size()));
		auto band = m_bb->bandAt(i);
		assert_return_void(band, "expected band");
		int xstart = band->xstart();
		int ystart = 0;
		auto& lst = m_band2glst[i];
		for (auto& j : lst)
		{
			repositionInBand(band, j, xstart, ystart);
			ystart += j->boundingRect().height();
		}

		if (ystart > m_max_ybottom) {
			m_max_ybottom = ystart + BBOARD_DELTA_EXPAND_HEIGHT;
			alignBandHeights();
		}
	}

	updateSelectedMarks();
};


template<class BB>
ard::board_g_topic<BB>* ard::board_page<BB>::firstSelected()
{
	if (!m_selected_marks.empty()) {
		auto i = *(m_selected_marks.begin());
		return i->g();
	}
	return nullptr;
};

template<class BB>
ard::GBLIST<BB> ard::board_page<BB>::selectedGBItems()
{
	GBLIST<BB> lst;
	for (auto& i : m_selected_marks) {
		lst.push_back(i->g());
	}
	return lst;
};

template<class BB>
void ard::board_page<BB>::clearSelectedGBItems()
{
	clearSelectedMarks();
};

template<class BB>
TOPICS_LIST ard::board_page<BB>::selectedRefTopics()
{
	TOPICS_LIST rv;
	TOPICS_SET res;
	for (auto& i : m_selected_marks) {
		auto t = i->g()->refTopic();
		auto j = res.find(t);
		if (j == res.end()) 
		{
			res.insert(t);
			rv.push_back(t);
		}
	}
	return rv;
};

template<class BB>
void ard::board_page<BB>::pushSelected() 
{
	m_stored_selected.clear();
	m_stored_selected.resize(m_bb->bands().size());
	for (auto& i : m_selected_marks) {
		auto band = i->g()->bandIndex();
		auto f = i->g()->refTopic();
		auto& lst = m_stored_selected[band];
		lst.push_back(f);
	}
};

template<class BB>
void ard::board_page<BB>::popSelected() 
{
	for(size_t band = 0; band < m_stored_selected.size(); band++)
	{
		TOPICS_LIST& lst = m_stored_selected[band];
		if (!lst.empty()) 
		{
			for (auto& f : lst) 
			{
				auto k = m_ref2glst.find(f);
				if (k != m_ref2glst.end()) 
				{
					for (auto& g : k->second) 
					{
						if (g->bandIndex() == band) 
						{
							selectGItem(g);
						}
					}
				}
			}
		}
	}
	m_stored_selected.clear();
};

template<class BB>
void ard::board_page<BB>::selectTopics(TOPICS_LIST& lst)
{
	if (!lst.empty())
	{
		for (auto& f : lst)
		{
			auto k = m_ref2glst.find(f);
			if (k != m_ref2glst.end())
			{
				for (auto& g : k->second)
				{
					selectGItem(g);
				}
			}
		}
	}
};

template<class BB>
void ard::board_page<BB>::selectGItem(board_g_topic<BB>* g) 
{
	auto m = new ard::selection_g_mark<BB>(this, g);
	m->updateMarkPos(g);
	m_selected_marks.push_back(m);
	m_scene->addItem(m);
	g->setMSelected(true);
};

template<class BB>
void ard::board_page<BB>::selectNext(Next2Item n) 
{
	auto g = firstSelected();
	if (g) 
	{
		auto bidx = g->bandIndex();
		auto Max = static_cast<int>(m_band2glst.size());
		assert_return_void(bidx >= 0 && bidx < Max, QString("selectNext/invalid band index [%1][%2][%3]").arg(bidx).arg(Max).arg(static_cast<int>(n)));
		switch (n)
		{
		case Next2Item::left:
			if (bidx > 0) {
				auto& lst = m_band2glst[bidx-1];
				auto yidx = closestToGItem(g, lst);
				if (yidx >= 0) {
					auto g2 = lst[yidx];
					selectAsCurrent(g2);
				}
			}break;
		case Next2Item::right: {
			if (bidx < Max-1) {
				auto& lst = m_band2glst[bidx + 1];
				auto yidx = closestToGItem(g, lst);
				if (yidx >= 0) {
					auto g2 = lst[yidx];
					selectAsCurrent(g2);
				}
			}break;
		}break;
		case Next2Item::up:
		{
			auto& lst = m_band2glst[bidx];
			auto yidx = indexOfGItem(g, lst);
			if (yidx > 0) {
				yidx--;
				auto g2 = lst[yidx];
				selectAsCurrent(g2);
			}
		}break;
		case Next2Item::down: 
		{
			auto& lst = m_band2glst[bidx];
			auto yidx = indexOfGItem(g, lst);
			if (yidx < static_cast<int>(lst.size()-1)) {
				yidx++;
				auto g2 = lst[yidx];
				selectAsCurrent(g2);
			}
		}break;
		default:
			break;
		}
	}
};

template<class BB>
int	ard::board_page<BB>::indexOfGItem(const board_g_topic<BB>* g, const GBLIST<BB>& lst)const
{
	int Max = static_cast<int>(lst.size());
	for (int i = 0; i < Max; i++) {
		if (lst[i] == g)return i;
	}
	return -1;
};

template<class BB>
int	ard::board_page<BB>::closestToGItem(const board_g_topic<BB>* g, const GBLIST<BB>& lst)const 
{
	if (lst.empty())return -1;
	auto g1 = lst[0];
#define CALC_DISTANCE(D) D = std::pow((g->pos().x() - g1->pos().x()), 2) + std::pow((g->pos().y() - g1->pos().y()), 2);

	double distance = 0;
	CALC_DISTANCE(distance);
	double prev_distance = distance;
	int i = 1;
	int Max = static_cast<int>(lst.size());
	while (i < Max) {
		//if (g->pos().y() > g1->pos().y() && g->pos().y() < (g1->pos().y() + g1->rect().height()))return (i-1);
		g1 = lst[i];		
		CALC_DISTANCE(distance);
		if (distance > prev_distance)return (i-1);
		prev_distance = distance;
		//qDebug() << i << "curr=" << distance << "prev=" << prev_distance << g1->refTopic()->title().left(20);
		i++;
	}

	return (Max-1);

#undef CALC_DISTANCE
};

template<class BB>
std::pair<bool, QString> ard::board_page<BB>::renameGItem(board_g_topic<BB>* g)
{
	std::pair<bool, QString> rv{ true, "" };
	auto f = g->refTopic();
	if (!f) {
		rv = { false, "Reference no resolved" };
		return rv;
	}

	if (!f->canRename()) {
		rv = { false, QString("Can't rename '%1'").arg(f->objName()) };
		return rv;
	}

	auto rc = g->boundingRect();
	int dy = gui::lineHeight() / 2 + 2*ARD_MARGIN;
	auto pt = g->pos();
	auto new_y = pt.y() - dy;
	auto new_x = pt.x() - dy;
	if (new_y < 0)new_y = 0;
	if (new_x < 0)new_x = 0;
	pt.setY(new_y);
	pt.setX(new_x);

	rc.setRect(new_x, rc.top(), rc.width() + 2 * dy, rc.height() + 2 * dy);
	auto pt_view = m_view->mapFromScene(pt);

	QRect rce(pt_view, QSize(rc.width() + 2 * dy, rc.height() + 2 * dy));
/*
	auto brct = g->boundingRect();// g->title_rect();
	auto top_l = brct.topLeft();
	top_l.setX(top_l.x() - gui::lineHeight());
	auto pt_scene = g->mapToScene(top_l);

	auto bandIndex = bandIndexAtPos(pt_scene.x());
	if (bandIndex == -1) {
		ASSERT(0, "invalid bindex") << bandIndex;
		return rv;
	}


	auto band = m_bb->bandAt(bandIndex);
	if (band) {
		auto j = m_band2g.find(band);
		if (j != m_band2g.end()) {
			auto bb = j->second;
			auto brc = bb->scenePos();
			if (pt_scene.x() < brc.x()) {
				pt_scene.setX(brc.x());
			}
			//pt_scene.setX(brc.x());
		}
	}


	//get here band index, then band left coord, use it for edit position calculation

	auto pt_view = m_view->mapFromScene(pt_scene);
	int w = BBOARD_BAND_DEFAULT_WIDTH - gui::lineHeight();
	if (brct.width() > w) {
		w = brct.width();
	}
	pt_view.setY(pt_view.y() - gui::lineHeight());
	if (pt_view.y() < 0)pt_view.setY(0);

	QRect rce(pt_view, QSize(w, 3 * gui::lineHeight()));
	if (static_cast<int>(brct.height()) > rce.height()) {
		rce.setHeight(brct.height());
	}
	*/

	ard::board_editor<BB>::editTitle(this, rce);
	return rv;
};

template<class BB>
ard::topic*	ard::board_page<BB>::firstSelectedRefTopic()
{
	auto g = firstSelected();
	if (g)return g->refTopic();
	return nullptr;
}

template<class BB>
void ard::board_page<BB>::selectAsCurrent(board_g_topic<BB>* g)
{
	clearSelectedGBItems();
	std::unordered_set<ard::board_g_topic<BB>*> sel_lst;
	sel_lst.insert(g);
	addMSelected(sel_lst);
	g->setFocus();
	clearCurrentRelated();

	//if (!m_curr_mark) {
	//	m_curr_mark = new board_g_mark<BB>(this);
	//	m_scene->addItem(m_curr_mark);
	//}
	setupActionButtonInCaseCustomEditMode();
	updateCurrentRelated(g);
	updateToolbar();
};

template<class BB>
ard::GBLIST<BB>& ard::board_page<BB>::findGBItems(ard::topic* refTopic)
{
	auto i = m_ref2glst.find(refTopic);
	if (i != m_ref2glst.end()) {
		return i->second;
	}

	static ard::GBLIST<BB> empty;
	return empty;
};

template<class BB>
std::unordered_set<int>	ard::board_page<BB>::gitems2bands(const GBLIST<BB>& lst) 
{
	std::unordered_set<int> rv;
	for (auto& i : lst)rv.insert(i->bandIndex());	
	return rv;
};

template<class BB>
void ard::board_page<BB>::resizeGBItems(ard::topic* refTopic)
{
	std::unordered_set<int> b2r;
	auto& lst = findGBItems(refTopic);
	if (!lst.empty()) {
		for (auto& j : lst) {
			auto bidx = j->bandIndex();
			auto band = m_bb->bandAt(bidx);
			assert_return_void(band, "expected band");
			b2r.insert(bidx);
			j->resize2Content(band);
		}
	}

	resetBand(b2r);
}

template<class BB>
std::unordered_set<int> ard::board_page<BB>::removeTopicGBItems(const TOPICS_LIST& refTopics)
{
	std::unordered_set<board_g_topic<BB>*> g2remove;
	std::unordered_set<int> b2r;
	for (auto& f : refTopics)
	{
		auto i = m_ref2glst.find(f);
		if (i != m_ref2glst.end()) {
			for (auto& j : i->second) {
				g2remove.insert(j);
				m_scene->removeItem(j);
				b2r.insert(j->bandIndex());
			}
			m_ref2glst.erase(i);
		}
		for (auto& i : b2r) 
		{
			if(i >= 0 && i < static_cast<int>(m_band2glst.size()))
			{
				auto& lst = m_band2glst[i];
				for (auto it = lst.begin(); it != lst.end();) {
					auto g = *it;
					if (g2remove.find(g) != g2remove.end()){
						it = lst.erase(it);
					}
					else{
						it++;
					}
				}
			}
		}
	}

	resetBand(b2r);
	return b2r;
};

template<class BB>
int ard::board_page<BB>::removeBandGBItems(int bindex)
{
	int rv = 0;
	TOPICS_SET topics2update;
	std::unordered_set<board_g_topic<BB>*> g2remove;
	///collect items to remove
	if (bindex >= 0 && bindex < static_cast<int>(m_band2glst.size()))
	{
		auto& lst = m_band2glst[bindex];
		for (auto& g : lst) { 
			g2remove.insert(g);
			topics2update.insert(g->refTopic()); 
		}
		lst.clear();
	}

	///remove from mselected list
	for (auto it = m_selected_marks.begin(); it != m_selected_marks.end();)
	{
		auto m = *it;
		if (g2remove.find(m->g()) != g2remove.end())
		{
			it = m_selected_marks.erase(it);
			m_scene->removeItem(m);
			//m_removed_links.push_back(lnk);
		}
		else
		{
			it++;
		}
	}

	///erase item from scene
	for(auto f : topics2update)
	{
		auto i = m_ref2glst.find(f);
		if (i != m_ref2glst.end()) {
			auto& lst = i->second;
			for (auto it = lst.begin(); it != lst.end();) {
				auto g = *it;
				if (g2remove.find(g) != g2remove.end()) {
					it = lst.erase(it);
					m_scene->removeItem(g);
					rv++;
				}
				else {
					it++;
				}
			}
		}
	}
	return rv;
};

template<class BB>
ard::board_g_topic<BB>* ard::board_page<BB>::ensureVisible(ard::topic* refTopic, bool animate)
{
	auto& lst = findGBItems(refTopic);
	if (!lst.empty()) {
		auto g = *(lst.begin());
		ensureVisible(g, animate);
		return g;
	}
	return nullptr;
};

template<class BB>
void ard::board_page<BB>::ensureVisible(ard::board_g_topic<BB>* g, bool animate)
{
	g->ensureVisible(QRectF(0, 0, 1, 1));
	auto ptg = g->boundingRect().center();
	ptg = g->mapToScene(ptg);
	if(animate)m_scene->animateLocator(ptg);
};



template<class BB>
void ard::board_page<BB>::applySelectionCommand(topic_function cmd)
{
	for (auto& i : m_selected_marks) 
	{
		auto f = i->g()->refTopic();
		if (f)cmd(f);
		auto l2 = findGBItems(f);
		for (auto j : l2)j->update();
	}
};


template<class BB>
void ard::board_page<BB>::registerBoardTopic(board_g_topic<BB>* g, board_band_info* band)
{
	assert_return_void(band->bandIndex() < static_cast<int>(m_band2glst.size()), "invalid band index");
	g->resize2Content(band);
	auto i = m_ref2glst.find(g->refTopic());
	if (i == m_ref2glst.end()) {
		GBLIST<BB> lst;
		lst.push_back(g);
		m_ref2glst[g->refTopic()] = lst;
	}
	else {
		i->second.push_back(g);
	}
	auto band_index = band->bandIndex();
	//auto j = m_band2glst.find(band_index);
	//if (j == m_band2glst.end()) 
	/*if()
	{
		GBLIST<BB> lst;
		lst.push_back(g);
		m_band2glst[band_index] = lst;
	}
	else {
		j->second.push_back(g);
	}*/
	m_band2glst[band_index].push_back(g);
	m_scene->addItem(g);
	g->setBandIndex(band_index);
	g->setOutlineIndex(m_outline_index++);
};

template<class BB>
TextFilter* ard::board_page<BB>::text_filter()
{
	return m_text_filter.get();
};

template<class BB>
ard::board_band<BB>* ard::board_page<BB>::bandAt(int band_index)
{
	for (auto& i : m_band2g) {
		if (i.first->bandIndex() == band_index)
			return i.second;
	}
	return nullptr;
};

template<class BB>
int ard::board_page<BB>::bandIndexAtPos(int xpos)
{
	auto& bands = m_bb->bands();
	int xband = 0;
	int bidx = 0;
	if (bands.size() > 0) {
		if (xpos < 0)
			return 0;

		for (auto& b : bands) {
			if (xpos >= xband && xpos <= (xband + b->bandWidth())) {
				return bidx;
			}
			xband += b->bandWidth();
			bidx++;
		}
	}
	return -1;
};


template<class BB>
void ard::board_page<BB>::initBandSplitter(int init_splitter_x)
{
	if (!m_band_splitter) {
		m_band_splitter = new board_band_splitter;
		m_scene->addItem(m_band_splitter);
	}

	m_band_splitter->show();
	m_band_splitter_init_x = init_splitter_x;
	m_band_splitter->updateXPos(m_band_splitter_init_x);
};

template<class BB>
void ard::board_page<BB>::resizeBandSplitter(int splitter_x)
{
	if (m_band_splitter)m_band_splitter->updateXPos(splitter_x);
};

template<class BB>
void ard::board_page<BB>::applyBandSplitter(int band_index, int splitter_x)
{
	auto band = m_bb->bandAt(band_index);
	if (band) {
		int dx = (splitter_x - m_band_splitter_init_x);
		auto w = band->bandWidth();
		w += dx;
		m_band_splitter->hide();

		if (m_bb->setBandWidth(band_index, w)) {
			rebuildBoard();
		};
	}
};

template<class BB>
void ard::board_page<BB>::applyBandSplitterSetDefaultSize(int band_index)
{
	auto band = m_bb->bandAt(band_index);
	if (band) {
		if (m_bb->setBandWidth(band_index, BBOARD_BAND_DEFAULT_WIDTH)) {
			rebuildBoard();
		};
	}
};


template<class BB>
void ard::board_page<BB>::updateHeader()
{
	for (auto& i : m_bh2g)i.second->update();
};

template<class BB>
std::pair<ard::board_band<BB>*, ard::board_band_header<BB>*> 
ard::board_page<BB>::register_band(ard::board_band_info* band)
{
	std::pair<ard::board_band<BB>*, ard::board_band_header<BB>*> rv;
	rv.first = new ard::board_band<BB>(this, band);
	rv.second = produceBandHeader(band);
	if (!rv.first || !rv.second) {
		ASSERT(0, "failed to register band");
		return rv;
	}
	m_band2g[band] = rv.first;
	m_bh2g[band] = rv.second;
	m_scene->addItem(rv.first);
	m_header_scene->addItem(rv.second);
	return rv;
};

template<class BB>
ard::board_band_header<BB>* ard::board_page<BB>::produceBandHeader(ard::board_band_info* band)
{
	return new ard::board_band_header<BB>(this, band);
};

template<class BB>
void ard::board_page<BB>::rebuildBands()
{
	for (auto i : m_band2g)m_scene->removeItem(i.second);
	m_band2g.clear();
	for (auto i : m_bh2g)m_header_scene->removeItem(i.second);
	m_bh2g.clear();
	m_band2glst.clear();

	const auto& bands = m_bb->bands();
	int columns_count = bands.size();
	if (!columns_count) {
		return;
	}

	m_max_xright = 0;
	QPointF pt(0, 0);
	for (int i = 0; i < columns_count; i++) 
	{
		auto bi = bands[i];
		bi->set_x_start(m_max_xright);
		m_max_xright += bi->bandWidth();

		auto res = register_band(bi);
		res.first->setPos(pt);
		res.second->setPos(pt);
		pt.setX(m_max_xright);

		GBLIST<BB> lst;
		m_band2glst.push_back(lst);
	}

	/// reset band colors ///
	int idx = 0;
	const int rgb_base = 80;
	const int rgb_delta = rgb_base / columns_count;
	for (auto b : bands) {
		int rgb_num = rgb_base - idx*rgb_delta;
		b->set_color(QColor(rgb_num, rgb_num, rgb_num));
		idx++;
	}
};

template<class BB>
void ard::board_page<BB>::repositionInBand(board_band_info* band, board_g_topic<BB>* g, int xpos, int ypos)
{
	qreal delta = 0.0;
	if (m_center_items_in_band) {
		auto w = g->boundingRect().width();
		if (w < band->bandWidth()) {
			delta = (band->bandWidth() - w) / 2;
		}
	}
	QPointF pt(xpos + delta, ypos);
	g->repositionInBand(band, pt);
};

template<class BB>
void ard::board_page<BB>::setCurrentBand(int band_idx)
{
	for (auto& i : m_bh2g) {
		if (i.first->bandIndex() == band_idx) {
			i.second->setCurrent(true);
		}
		else {
			i.second->setCurrent(false);
		}
	}
};

template<class BB>
int	ard::board_page<BB>::currentBand()const 
{
	for (auto& i : m_bh2g) {
		if (i.second->isCurrent())
			return i.first->bandIndex();
	}
	return -1;
};

template<class BB>
void ard::board_page<BB>::clearBoard()
{
	m_band2g.clear();
	m_bh2g.clear();
	m_ref2glst.clear();
	m_band2glst.clear();
	m_selected_marks.clear();
	m_scene->clearArdScene();
	m_header_scene->clearArdScene();
	//m_curr_mark = nullptr;
	m_band_splitter = nullptr;
	m_mselector = nullptr;
	m_outline_index = 0;
};

template<class BB>
void ard::board_page<BB>::alignBandHeights()
{
	for (auto i : m_band2g)i.second->updateSize(m_max_ybottom);
	auto rc2 = QRectF(0, 0, m_max_xright, m_max_ybottom);
	m_scene->setSceneRect(rc2);
	rc2 = QRectF(0, 0, m_max_xright, gui::lineHeight());
	m_header_scene->setSceneRect(rc2);
};

template<class BB>
void ard::board_page<BB>::makeThumbnail()
{
	if (m_bb && m_view) {
		auto pm = m_view->grab();
		if (!pm.isNull()) {
			m_bb->setThumbnail(pm);
		}
	}
	/*if (m_bb && m_scene) {
		QImage image(m_view->viewport()->size(), QImage::Format_ARGB32);
		image.fill(Qt::transparent);
		QPainter painter(&image);
		m_scene->render(&painter);
		auto pm = QPixmap::fromImage(image);
		if (!pm.isNull()) {
			m_bb->setThumbnail(pm);
		}
	}*/
};

template<class BB>
void ard::board_page<BB>::attachTopic(BB* b)
{
	m_bb = b;
	LOCK(m_bb);
	rebuildBoard();
	if (m_bb->autogenerateThumbnail())
	{
		auto th = m_bb->thumbnail();
		if (th && (th->isNull() || m_bb->isThumbnailEmpty()))
		{
			QTimer::singleShot(1000, [=]()
			{
				makeThumbnail();
			});
		}
	}
};

template<class BB>
void ard::board_page<BB>::saveModified()
{
	if (m_bb) {
		if (m_bb->isThumbDirty()) {
			makeThumbnail();
		}
		else {
			auto th = m_bb->thumbnail();
			if (th && (th->isNull() || m_bb->isThumbnailEmpty())) {
				makeThumbnail();
			}
		}
		m_bb->ensurePersistant(-1);
	}
};

template<class BB>
void ard::board_page<BB>::detachCardOwner()
{
	if (m_bb) {
		saveModified();
		m_bb->release();
		m_bb = nullptr;
	}
};

template<class BB>
void ard::board_page<BB>::updateCurrentRelated(board_g_topic<BB>* )
{
};

template<class BB>
void ard::board_page<BB>::clearCurrentRelated()
{

};

template<class BB>
void ard::board_page<BB>::clearSelectedMarks()
{
	for (auto& m : m_selected_marks) {
		m->g()->setMSelected(false);
		m_scene->removeItem(m);
	}
	m_selected_marks.clear();
	if (m_mselector)m_mselector->updateSelectRect(QRectF());	
}

template<class BB>
void ard::board_page<BB>::updateSelectedMarks() 
{
	for (auto& m : m_selected_marks)m->updateSelectionMark();
};

template<class BB>
void ard::board_page<BB>::initMSelect(QPointF ptScene)
{
	if (!m_mselector) {
		m_mselector = new ard::board_selector_rect;
		m_scene->addItem(m_mselector);
	}
	m_ptMselectorStart = ptScene;
};

template<class BB>
void ard::board_page<BB>::updateMSelected()
{
	for (auto& i : m_selected_marks) {
		i->g()->update();
	}
};


template<class BB>
bool ard::board_page<BB>::isMSelected(board_g_topic<BB>* g)const
{
	for (auto i : m_selected_marks){
		if (i->g() == g)return true;
	}
	return false;
};

template<class BB>
bool ard::board_page<BB>::hasMSelection()const
{
	return !m_selected_marks.empty();
};

template<class BB>
void ard::board_page<BB>::addMSelected(std::unordered_set<ard::board_g_topic<BB>*>& sel_lst)
{
	std::vector<ard::board_g_topic<BB>*> lst;
	std::unordered_set<board_g_topic<BB>*> sel_set;
	for (auto& i : m_selected_marks) {
		sel_set.insert(i->g());
	}

	for (auto& g : sel_lst) {
		auto j = sel_set.find(g);
		if (j == sel_set.end()) {
			lst.push_back(g);
		}
	}

	for (auto& g : lst)selectGItem(g);	

	prepareMSelected();
};

template<class BB>
void ard::board_page<BB>::updateToolbar()
{
	m_toolbar->sync2Board();
}

template<class BB>
void ard::board_page<BB>::prepareMSelected()
{
	std::sort(m_selected_marks.begin(), m_selected_marks.end(), [](ard::selection_g_mark<BB>* m1, ard::selection_g_mark<BB>* m2)
	{
		bool rv = m1->g()->sceneBoundingRect().top() < m2->g()->sceneBoundingRect().top();
		return rv;
	});

	if (m_mselector) {
		m_mselector->updateSelectRect(QRectF());
	}
};

template<class BB>
int ard::board_page<BB>::resizeMSelect(QPointF ptScene)
{
	int len = 0;
	QLineF line_from_to(m_ptMselectorStart, ptScene);
	len = (int)line_from_to.length();

	if (m_mselector) {
		QRectF rc(m_ptMselectorStart, ptScene);
		if (rc.isEmpty()) {
			rc = QRectF(ptScene, m_ptMselectorStart);
		}
		m_mselector->updateSelectRect(rc);
	}
	return len;
};

template<class BB>
bool ard::board_page<BB>::completeMSelect()
{
	ard::board_g_topic<BB>* topGItemInMSelect = nullptr;

	if (m_mselector) {
		auto rc = m_mselector->sceneBoundingRect();
		clearSelectedGBItems();

		auto lst = m_scene->items(rc);
		for (auto i : lst) {
			auto gb = dynamic_cast<ard::board_g_topic<BB>*>(i);
			if (gb)
			{
				selectGItem(gb);
				if (!topGItemInMSelect) {
					topGItemInMSelect = gb;
				}
				else {
					if (gb->sceneBoundingRect().top() > topGItemInMSelect->sceneBoundingRect().top()) {
						topGItemInMSelect = gb;
					}
				}
			}
		}

		prepareMSelected();
		m_mselector->updateSelectRect(QRectF());
	}
	
	
	bool rv = !m_selected_marks.empty();
	if (rv) {
		clearCurrentRelated();
		if (isInCustomEditMode()) {
			repositionActionButtons(topGItemInMSelect);
		}
	}

	return rv;
}

template<class BB>
void ard::board_page<BB>::selectAllGBItems() 
{
	clearSelectedGBItems();
	for (auto& i : m_ref2glst) 
	{
		for (auto& j : i.second) 
		{
			if (!j->isSelected())j->setSelected(true);
			selectGItem(j);
		}
	}

	prepareMSelected();
};

template<class BB>
void ard::board_page<BB>::editComment(board_g_topic<BB>* g)
{
	ard::popup_annotation(g->refTopic());
	/*
	auto brct = g->title_rect();
	auto pt_scene = g->mapToScene(brct.topLeft());
	auto pt_view = m_view->mapFromScene(pt_scene);
	pt_view.setY(pt_view.y() - 2 * gui::lineHeight());
	if (pt_view.y() < 0)
		pt_view.setY(0);
	int w = BBOARD_BAND_DEFAULT_WIDTH - gui::lineHeight();
	if (brct.width() > w) {
		w = brct.width();
	}
	QRect rce(pt_view, QSize(w, 3 * gui::lineHeight()));
	board_editor<BB>::editAnnotation(this, rce);*/
};

template<class BB>
void ard::board_page<BB>::enterEditMode(ard::board_editor<BB>* e)
{
	m_curr_editor = e;
};

template<class BB>
void ard::board_page<BB>::exitEditMode()
{
	if (m_curr_editor) {
		m_curr_editor->close();
		m_curr_editor = nullptr;
	}
};

template<class BB>
void ard::board_page<BB>::detachEditor()
{
	m_curr_editor = nullptr;
};

template<class BB>
void ard::board_page<BB>::showProperties()
{
	auto f = firstSelectedRefTopic();
	if (f) {
		ard::asyncExec(AR_ViewProperties, f);
	}
};

template<class BB>
void ard::board_page<BB>::locateInSelector()
{
	auto f = firstSelectedRefTopic();
	if (f) {
		register_no_popup_slide(f);
		gui::ensureVisibleInOutline(f);
	}
};

template<class BB>
void ard::board_page<BB>::copyToClipboard()
{
	auto cb = QApplication::clipboard();
	if (cb)
	{
		auto lst = selectedRefTopics();
		if (!lst.empty()) {
			auto mm = new ard::TopicsListMime(lst.begin(), lst.end());
			cb->setMimeData(mm);
		}
	}
};